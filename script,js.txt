// Variable global para almacenar los archivos cargados
let loadedFiles = [];
let audioFile = null;

// Referencias a elementos del DOM (Conexi√≥n con los IDs de index.html)
const videoFileInput = document.getElementById('video-files');
const audioFileInput = document.getElementById('audio-file');
const timelineClips = document.getElementById('timeline-clips');
const generateButton = document.getElementById('generate-btn');
const textInput = document.getElementById('text-input');
const previewDisplay = document.getElementById('preview-display');

// ------------------------------------------
// 1. L√ìGICA DE CARGA DE ARCHIVOS
// ------------------------------------------

// Maneja la carga de m√∫ltiples im√°genes/videos
videoFileInput.addEventListener('change', (event) => {
    const newFiles = Array.from(event.target.files);
    
    newFiles.forEach(file => {
        // Asigna un ID √∫nico: Python lo necesita para identificar cada archivo
        file.uniqueId = 'clip-' + Date.now() + '-' + Math.random().toString(36).substring(2, 9);
        loadedFiles.push(file);
        
        // Actualiza la visualizaci√≥n
        addClipToTimeline(file);
        updateSimplePreview(file);
    });

    event.target.value = null; // Limpia el input
});

// Maneja la carga del archivo de audio
audioFileInput.addEventListener('change', (event) => {
    audioFile = event.target.files[0];
    alert(`üéµ Audio cargado: ${audioFile.name}`);
});

// ------------------------------------------
// 2. VISUALIZACI√ìN SIMPLE
// ------------------------------------------

function addClipToTimeline(file) {
    const li = document.createElement('li');
    li.id = file.uniqueId;
    // Muestra el nombre y tipo de archivo en la l√≠nea de tiempo
    li.textContent = `${file.name.substring(0, 20)}... (${file.type.split('/')[0]})`;
    li.dataset.fileId = file.uniqueId;
    timelineClips.appendChild(li);
}

function updateSimplePreview(file) {
    previewDisplay.innerHTML = ''; 
    const fileURL = URL.createObjectURL(file); // URL temporal para mostrar el archivo

    // Muestra la imagen o el video en el √°rea de previsualizaci√≥n
    if (file.type.startsWith('image')) {
        const img = document.createElement('img');
        img.src = fileURL;
        img.style.maxWidth = '100%';
        img.style.maxHeight = '100%';
        previewDisplay.appendChild(img);
    } else if (file.type.startsWith('video')) {
        const video = document.createElement('video');
        video.src = fileURL;
        video.controls = true;
        video.autoplay = true;
        video.loop = true;
        video.style.maxWidth = '100%';
        video.style.maxHeight = '100%';
        previewDisplay.appendChild(video);
    }
    
    // Vuelve a a√±adir el campo de texto (para que est√© encima de la previsualizaci√≥n)
    previewDisplay.appendChild(textInput);
}

// ------------------------------------------
// 3. GENERACI√ìN Y ENV√çO A PYTHON
// ------------------------------------------

generateButton.addEventListener('click', async () => {
    if (loadedFiles.length === 0) {
        alert("üö® Por favor, carga al menos una imagen o video.");
        return;
    }

    // 1. Obtener el orden de los clips de la l√≠nea de tiempo
    const timelineOrder = Array.from(timelineClips.children).map(li => li.dataset.fileId);

    // 2. Crear la configuraci√≥n JSON (instrucciones para Python)
    const config = {
        clips: timelineOrder.map(id => {
            const file = loadedFiles.find(f => f.uniqueId === id);
            return {
                id: file.uniqueId,
                name: file.name,
                type: file.type,
                // Le decimos a Python la duraci√≥n que queremos (5s para im√°genes)
                duration: file.type.startsWith('image') ? 5 : null, 
            };
        }),
        audioName: audioFile ? audioFile.name : null,
        text: textInput.value || ""
    };
    
    // 3. Empaquetar todo en FormData (el "sobre" para enviar)
    const formData = new FormData();
    formData.append('config', JSON.stringify(config)); // Las instrucciones

    // Los archivos multimedia (im√°genes, videos, audio)
    loadedFiles.forEach(file => {
        formData.append(file.uniqueId, file, file.name); 
    });
    if (audioFile) {
        formData.append('audio_file', audioFile, audioFile.name);
    }

    alert("‚öôÔ∏è Enviando archivos a Python para procesamiento...");
    generateButton.disabled = true; // Deshabilita el bot√≥n

    // 4. Enviar a Python (a la ruta /generate-reel que crearemos en app.py)
    try {
        const response = await fetch('/generate-reel', {
            method: 'POST',
            body: formData 
        });

        if (response.ok) {
            // 5. Descargar el MP4 devuelto por Python
            const blob = await response.blob();
            const url = window.URL.createObjectURL(blob);
            
            // Simula el clic en un enlace de descarga
            const a = document.createElement('a');
            a.href = url;
            a.download = 'reel_final_' + Date.now() + '.mp4';
            document.body.appendChild(a);
            a.click();
            a.remove();
            window.URL.revokeObjectURL(url);
            alert("‚úÖ ¬°Reel generado y descargado con √©xito!");
        } else {
            const errorText = await response.text();
            alert(`‚ùå Error al generar el Reel: ${errorText}`);
        }
    } catch (error) {
        console.error('Error de red:', error);
        alert('‚ùå Error de conexi√≥n con el servidor Python.');
    } finally {
        generateButton.disabled = false; // Vuelve a habilitar el bot√≥n
    }
});